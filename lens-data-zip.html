<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-selector/iron-selector.html">
<!-- <link rel="import" href="../core-input/core-input.html">

<!--
A transform component that zips two arrays of objects together based on a common key.

##### Example

    <lens-data-zip></lens-data-zip>

@element lens-data-zip
@blurb A transform component that zips two arrays of objects together based on a common key.
@status alpha
@homepage http://lenses.github.io/lens-data-zip
-->
<dom-module id="lens-data-zip">
  <link rel="import" type="css" href="lens-data-zip.css">
  <template>
    <div class="lens-container lens-data">

        <p class="info">Zips two datasets together based on a common key</p>
        <label class="label" for="func_selector">Key1:</label>
        <iron-selector class="selector" id="value_selector0" selected="{{zipColKey0}}" attr-for-selected="label">
          <template is="dom-repeat" items="{{_dataAttributes0}}" as="attr">
            <div class="col" label="{{attr}}">{{attr}}</div>
          </template>
        </iron-selector>
        <label class="label" for="func_selector">Key2:</label>
        <iron-selector class="selector" id="value_selector1" selected="{{zipColKey1}}" attr-for-selected="label">
          <template is="dom-repeat" items="{{_dataAttributes1}}" as="attr">
            <div class="col" label="{{attr}}">{{attr}}</div>
          </template>
        </iron-selector>
        <label class="label">Zip (Join) Type:</label>
        <iron-selector class="selector" id="join_type" selected="{{joinType}}" attr-for-selected="label">
            <div class="col" label="inner">Strict/Inner</div>
            <div class="col" label="outer">Full/Outer</div>
        </iron-selector>
        <label class="label">Remove duplicate column:</label>
        <input type="checkbox" checked="{{removeDuplicates}}">
    </div>  <!-- end container-->

  </template>
</dom-module>
<script>
  Polymer({
    is: 'lens-data-zip',
    properties: {
      beSmart: { observer: '_calculateOutput' },
      input: {
        notify: true,
        observer: 'inputChanged'
      },
      input_aux: {
        notify: true,
        observer: 'input_auxChanged'
      },
      joinType: {
        type: String,
        value: 'inner',
        notify: true,
        observer: '_calculateOutput'
      },
      output: { notify: true },
      removeDuplicates: {
        type: Boolean,
        value: true,
        observer: '_calculateOutput'
      },
      zipColKey0: {
        value: null,
        notify: true,
        observer: '_calculateOutput'
      },
      zipColKey1: {
        value: null,
        notify: true,
        observer: '_calculateOutput'
      }
    },
    // Called when <th-data-split> element is created.
    ready: function () {
    },
    // Change watcher for input attribute. Triggered wheneve input is changed
    inputChanged: function () {
      var self = this;
      if (!self.input || !self.input.length > 0) {
        return;
      }
      var firstItem = self.input[0];
      if (!firstItem) {
        return;
      }
      var attributes = Object.keys(firstItem);
      if (JSON.stringify(self._dataAttributes0) === JSON.stringify(attributes)) {
      }  //self._mapChartData();
      else
        //self._mapChartData();
        {
          self._dataAttributes0 = attributes;
        }
      self._calculateOutput();
    },
    input_auxChanged: function () {
      var self = this;
      if (!self.input_aux || !self.input_aux.length > 0) {
        return;
      }
      var firstItem = self.input_aux[0];
      if (!firstItem) {
        return;
      }
      var attributes = Object.keys(firstItem);
      if (JSON.stringify(self._dataAttributes1) === JSON.stringify(attributes)) {
      }  //self._mapChartData();
      else
        //self._mapChartData();
        {
          self._dataAttributes1 = attributes;
        }
      self._calculateOutput();
    },
    // Calculates output from input based on settings
    _calculateOutput: function () {
      var self = this;
      if (self.zipColKey1 && self.zipColKey1) {
        //var intersect = _.intersection(_.pluck(self.input, self.zipColKey1), _.pluck(self.input, self.zipColKey1));
        //console.log(intersect);
        // console.log('key',self.zipColKey0);
        var input0 = _.map(self.input, function (item) {
          item['__toZip'] = item[self.zipColKey0];
          return item;
        });
        var input1 = _.map(self.input_aux, function (item) {
          item['__toZip'] = item[self.zipColKey1];
          return item;
        });
        var grouped = _.groupBy(input0.concat(input1), '__toZip');  // console.log(grouped);
                                                                    /*
                                                                              grouped.map(grouped, function(item) {
                                                                                var key = Object.keys(item)[0];
                                                                                var ret = {};
                                                                                //ret[self.zipColKey0] = key;
                                                                                console.log(key);
                                                                                if(item[key].length>1) {
                                                                                  _.assign(ret, item[key][0], item[key][1]);
                                                                                  console.log(ret);
                                                                                }
                                                                                return ret;
                                                                    
                                                                              })
                                                                    
                                                                    */
        // console.log(grouped);
        /*
                  grouped.map(grouped, function(item) {
                    var key = Object.keys(item)[0];
                    var ret = {};
                    //ret[self.zipColKey0] = key;
                    console.log(key);
                    if(item[key].length>1) {
                      _.assign(ret, item[key][0], item[key][1]);
                      console.log(ret);
                    }
                    return ret;
        
                  })
        
        */
        self.output = [];  // console.log(self.joinType);
        // console.log(self.joinType);
        _.forIn(grouped, function (value, key) {
          var ret = {};
          console.log(key, value);  //when there is nothing to groupby lodash groups them under undefined
          //when there is nothing to groupby lodash groups them under undefined
          if (key !== 'undefined') {
            //if inner join, only merge when there are at least two values grouped
            if (self.joinType === 'outer' || value.length > 1) {
              _.assign(ret, value[0], value[1]);
              delete ret['__toZip'];  // console.log('remove dupes', self.removeDuplicates);
              // console.log('remove dupes', self.removeDuplicates);
              if (self.removeDuplicates && self.zipColKey0 !== self.zipColKey1 && ret[self.zipColKey0]) {
                delete ret[self.zipColKey1];
              }  // console.log(ret);
              // console.log(ret);
              self.output.push(ret);
            }
          }
        });  // console.log(self.output);
        self.fire('lens-output-changed', self.output);
      }
    }
  });
</script><script src="../lodash/lodash.js"></script>
